# Git Worktree Functions for Claude Code Parallel Development
# Managed by Ansible - git role
# Based on: https://medium.com/@dtunai/mastering-git-worktrees-with-claude-code-for-parallel-development-workflow-41dc91e645fe

# Base directory for all worktrees
# Worktrees will be organized as: $GIT_WORKTREE_BASE_DIR/<repo-name>/<worktree-name>
set -g GIT_WORKTREE_BASE_DIR "$HOME/dev/worktrees"

# Helper function to get the worktree path for a given name
function _gtr_get_worktree_path --description "Get the full path for a worktree"
    if test (count $argv) -ne 1
        return 1
    end

    set -l name $argv[1]

    # Check if we're in a git repository
    if not git rev-parse --git-dir >/dev/null 2>&1
        echo "Error: Not in a git repository" >&2
        return 1
    end

    # Get the repository name
    set -l repo_name (basename (git rev-parse --show-toplevel))

    # Construct path: ~/dev/worktrees/<repo-name>/<worktree-name>
    echo "$GIT_WORKTREE_BASE_DIR/$repo_name/$name"
end

# Helper function to get the repo-specific worktree directory
function _gtr_get_repo_worktree_dir --description "Get the worktree directory for current repo"
    if not git rev-parse --git-dir >/dev/null 2>&1
        return 1
    end

    set -l repo_name (basename (git rev-parse --show-toplevel))
    echo "$GIT_WORKTREE_BASE_DIR/$repo_name"
end

# gtr - Git worktree helper
# Main command dispatcher for worktree operations
function gtr --description "Git worktree helper for Claude Code parallel development"
    if test (count $argv) -lt 1
        echo "Usage: gtr {create|finish|done|cd|claude|list|rm|prune} [args...]"
        echo ""
        echo "Primary Workflow:"
        echo "  create <name>     Create worktree and cd into it"
        echo "  finish            Commit, merge to main, cleanup (run from worktree)"
        echo ""
        echo "Other Commands:"
        echo "  done [name]       Cleanup after external merge (auto-detects current worktree)"
        echo "  cd <name>         Change directory to a worktree"
        echo "  claude <name>     Launch Claude Code in a worktree"
        echo "  list              List all worktrees"
        echo "  rm <name...>      Remove one or more worktrees"
        echo "  prune             Clean up stale worktree references"
        echo ""
        echo "Simple Workflow Example:"
        echo "  gtr create my-feature    # Create and enter worktree"
        echo "  # ... do your work ..."
        echo "  /commit                  # Commit changes (in Claude Code)"
        echo "  gtr finish               # Merge, cleanup - done!"
        echo ""
        echo "Path: \$HOME/dev/worktrees/<repo-name>/<worktree-name>"
        return 1
    end

    set -l cmd $argv[1]
    set -e argv[1]

    switch $cmd
        case create
            _gtr_create $argv
        case finish
            _gtr_finish
        case done
            _gtr_done $argv
        case rm remove
            _gtr_remove $argv
        case cd
            _gtr_cd $argv
        case claude
            _gtr_claude $argv
        case list ls
            _gtr_list
        case prune
            _gtr_prune
        case '*'
            echo "Unknown command: $cmd"
            echo "Run 'gtr' without arguments for usage help"
            return 1
    end
end

# Internal: Create worktrees
function _gtr_create --description "Create git worktrees"
    if test (count $argv) -lt 1
        echo "Usage: gtr create <name...>"
        return 1
    end

    set -l last_created_path ""

    for name in $argv
        set -l worktree_path (_gtr_get_worktree_path $name)
        or return 1

        set -l branch_name "claude/$name"

        if test -d "$worktree_path"
            echo "Worktree already exists: $worktree_path"
            continue
        end

        # Ensure the repo-specific worktree directory exists
        set -l repo_dir (_gtr_get_repo_worktree_dir)
        if not test -d "$repo_dir"
            mkdir -p "$repo_dir"
        end

        echo "Creating worktree '$name' at $worktree_path (branch: $branch_name)..."
        git worktree add -b "$branch_name" "$worktree_path"

        if test $status -eq 0
            echo "âœ“ Worktree '$name' created successfully"
            set last_created_path "$worktree_path"
        else
            echo "âœ— Failed to create worktree '$name'"
        end
    end

    # If only one worktree was requested and it was created successfully, cd into it
    if test (count $argv) -eq 1 -a -n "$last_created_path"
        cd "$last_created_path"
    end
end

# Internal: Remove worktrees
function _gtr_remove --description "Remove git worktrees"
    if test (count $argv) -lt 1
        echo "Usage: gtr rm <name...>"
        return 1
    end

    for name in $argv
        set -l worktree_path (_gtr_get_worktree_path $name)
        or return 1

        if not test -d "$worktree_path"
            echo "Worktree does not exist: $worktree_path"
            continue
        end

        echo "Removing worktree '$name'..."
        git worktree remove "$worktree_path"

        if test $status -eq 0
            echo "âœ“ Worktree '$name' removed successfully"
        else
            echo "âœ— Failed to remove worktree '$name'"
        end
    end
end

# Internal: Change to worktree directory
function _gtr_cd --description "Change to a worktree directory"
    if test (count $argv) -ne 1
        echo "Usage: gtr cd <name>"
        return 1
    end

    set -l name $argv[1]
    set -l worktree_path (_gtr_get_worktree_path $name)
    or return 1

    if not test -d "$worktree_path"
        echo "Worktree does not exist: $worktree_path"
        return 1
    end

    cd "$worktree_path"
end

# Internal: Launch Claude Code in worktree
function _gtr_claude --description "Launch Claude Code in a worktree"
    if test (count $argv) -ne 1
        echo "Usage: gtr claude <name>"
        return 1
    end

    set -l name $argv[1]
    set -l worktree_path (_gtr_get_worktree_path $name)
    or return 1

    if not test -d "$worktree_path"
        echo "Worktree '$name' doesn't exist."
        read -l -P "Create it now? [y/N] " reply

        switch $reply
            case y Y yes YES
                echo "Creating worktree '$name'..."

                # Ensure the repo-specific worktree directory exists
                set -l repo_dir (_gtr_get_repo_worktree_dir)
                if not test -d "$repo_dir"
                    mkdir -p "$repo_dir"
                end

                set -l branch_name "claude/$name"
                git worktree add -b "$branch_name" "$worktree_path"

                if test $status -ne 0
                    echo "âœ— Failed to create worktree"
                    return 1
                end
            case '*'
                echo "Aborted."
                return 1
        end
    end

    # Launch Claude Code in the worktree directory
    pushd "$worktree_path"
    claude
    popd
end

# Internal: List all worktrees
function _gtr_list --description "List all git worktrees"
    git worktree list
end

# Internal: Prune stale worktree references
function _gtr_prune --description "Clean up stale worktree references"
    echo "Pruning stale worktree references..."
    git worktree prune -v
end

# Internal: Finish workflow - commit, merge to main, cleanup, all from worktree
function _gtr_finish --description "Complete workflow: commit, merge to main, cleanup from worktree"
    # Auto-detect current worktree
    set -l current_path (pwd)
    set -l repo_dir (_gtr_get_repo_worktree_dir)

    # Check if we're in a worktree subdirectory
    if not string match -q "$repo_dir/*" "$current_path"
        echo "Error: Must be run from within a worktree"
        echo "Current path: $current_path"
        return 1
    end

    # Extract worktree name from path
    set -l name (string replace "$repo_dir/" "" $current_path | cut -d'/' -f1)
    set -l branch_name "claude/$name"
    # Get main repo location (first entry in worktree list is always the main repo)
    set -l main_worktree (git worktree list | head -1 | awk '{print $1}')

    echo "Working in worktree: $name (branch: $branch_name)"
    echo ""

    # Check if there are uncommitted changes
    if not git diff-index --quiet HEAD --
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "âš  Uncommitted changes detected!"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        git status --short
        echo ""
        echo "Please commit your changes first, then run 'gtr finish' again."
        echo ""
        echo "Recommended: Use '/commit' in Claude Code for conventional commits"
        echo "Or manually: git add -A && git commit -m \"your message\""
        echo ""
        return 1
    end

    echo "âœ“ All changes committed"

    # Push to remote
    echo ""
    echo "Pushing to remote..."
    git push -u origin "$branch_name"

    if test $status -ne 0
        echo "âœ— Failed to push to remote"
        return 1
    end
    echo "âœ“ Pushed to remote"

    # Get default branch
    set -l default_branch (git remote show (git remote) | awk '/HEAD branch/ {print $NF}')

    # Switch to main repository
    echo ""
    echo "Switching to main repository..."
    cd "$main_worktree"
    git checkout "$default_branch"

    if test $status -ne 0
        echo "âœ— Failed to checkout $default_branch"
        return 1
    end

    # Pull latest changes
    echo "Pulling latest changes..."
    git pull

    if test $status -ne 0
        echo "âœ— Failed to pull latest changes"
        return 1
    end

    # Merge the branch
    echo ""
    echo "Merging $branch_name into $default_branch..."
    git merge "$branch_name" --no-edit

    if test $status -ne 0
        echo "âœ— Failed to merge $branch_name"
        echo "You may need to resolve conflicts manually"
        return 1
    end
    echo "âœ“ Merged successfully"

    # Push to remote
    echo "Pushing merge to remote..."
    git push

    if test $status -ne 0
        echo "âœ— Failed to push merge"
        return 1
    end
    echo "âœ“ Pushed to remote"

    # Clean up worktree
    echo ""
    echo "Cleaning up worktree '$name'..."
    set -l worktree_path (_gtr_get_worktree_path $name)
    git worktree remove "$worktree_path"

    if test $status -ne 0
        echo "âœ— Failed to remove worktree"
        return 1
    end

    # Delete local branch
    echo "Deleting local branch '$branch_name'..."
    git branch -d "$branch_name"

    if test $status -ne 0
        echo "âœ— Failed to delete local branch (may need -D to force)"
    end

    # Summary
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "âœ“ Workflow complete!"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "  Work committed and merged to $default_branch"
    echo "  Worktree '$name' removed"
    echo "  Branch '$branch_name' deleted"
    echo "  Currently on: $default_branch in main repo"
    echo ""
end

# Internal: Complete workflow after PR merge - cleanup and return to main
function _gtr_done --description "Clean up worktree after PR merge and return to main"
    set -l name ""

    # If no argument provided, try to auto-detect current worktree
    if test (count $argv) -eq 0
        set -l current_path (pwd)
        set -l repo_dir (_gtr_get_repo_worktree_dir)

        # Check if we're in a worktree subdirectory
        if string match -q "$repo_dir/*" "$current_path"
            # Extract worktree name from path
            set name (string replace "$repo_dir/" "" $current_path | cut -d'/' -f1)
            echo "Auto-detected worktree: $name"
        else
            echo "Usage: gtr done [name]"
            echo "Not currently in a worktree, please specify the worktree name"
            return 1
        end
    else if test (count $argv) -eq 1
        set name $argv[1]
    else
        echo "Usage: gtr done [name]"
        return 1
    end

    set -l worktree_path (_gtr_get_worktree_path $name)
    or return 1

    if not test -d "$worktree_path"
        echo "Worktree does not exist: $worktree_path"
        return 1
    end

    set -l branch_name "claude/$name"
    set -l current_path (pwd)
    # Get main repo location (first entry in worktree list is always the main repo)
    set -l main_worktree (git worktree list | head -1 | awk '{print $1}')

    # Check if we're currently in the worktree being removed
    set -l need_to_move false
    if string match -q "$worktree_path*" "$current_path"
        set need_to_move true
        echo "Currently in worktree '$name', moving to main repository..."
    end

    # Move to main worktree if needed
    if test "$need_to_move" = true
        cd "$main_worktree"
    end

    # Get the default branch name
    set -l default_branch (git remote show (git remote) | awk '/HEAD branch/ {print $NF}')

    # Checkout default branch
    echo "Checking out $default_branch..."
    git checkout $default_branch

    if test $status -ne 0
        echo "âœ— Failed to checkout $default_branch"
        return 1
    end

    # Pull latest changes
    echo "Pulling latest changes..."
    git pull

    # Remove the worktree
    echo "Removing worktree '$name'..."
    git worktree remove "$worktree_path"

    if test $status -ne 0
        echo "âœ— Failed to remove worktree '$name'"
        return 1
    end

    # Delete the local branch
    echo "Deleting local branch '$branch_name'..."
    git branch -d "$branch_name"

    if test $status -eq 0
        echo "âœ“ Cleanup complete!"
        echo "  - Worktree removed: $name"
        echo "  - Branch deleted: $branch_name"
        echo "  - On branch: $default_branch"
    else
        echo "âœ— Failed to delete branch '$branch_name'"
        echo "  You may need to use 'git branch -D $branch_name' to force delete"
    end
end

# Convenience aliases for common git worktree operations
alias gwt='git worktree'
alias gwtl='git worktree list'
alias gwta='git worktree add'
alias gwtr='git worktree remove'
alias gwtp='git worktree prune'

# Additional helper functions

# gwt-cleanup-merged - Remove worktrees for branches that have been merged
function gwt-cleanup-merged --description "Remove worktrees for merged branches"
    echo "Finding worktrees for merged branches..."

    set -l default_branch (git remote show (git remote) | awk '/HEAD branch/ {print $NF}')
    set -l merged_branches (git branch --merged $default_branch | string trim | grep -v "^\\*" | grep "claude/")

    if test -z "$merged_branches"
        echo "No merged 'claude/*' branches found."
        return 0
    end

    echo "Merged branches:"
    for branch in $merged_branches
        echo "  - $branch"
    end

    read -l -P "Remove worktrees for these merged branches? [y/N] " reply

    switch $reply
        case y Y yes YES
            set -l current_path (pwd)
            # Get main repo location (first entry in worktree list is always the main repo)
            set -l main_worktree (git worktree list | head -1 | awk '{print $1}')
            set -l moved_to_main false

            # Check if we're in any of the worktrees being removed
            for branch in $merged_branches
                set -l branch_name (string replace "claude/" "" $branch)
                set -l worktree_path (_gtr_get_worktree_path $branch_name)

                if test -d "$worktree_path"; and string match -q "$worktree_path*" "$current_path"
                    echo "Currently in worktree '$branch_name' which will be removed"
                    echo "Moving to main repository on $default_branch..."
                    cd "$main_worktree"
                    git checkout $default_branch
                    set moved_to_main true
                    break
                end
            end

            # Remove all merged worktrees
            for branch in $merged_branches
                set -l branch_name (string replace "claude/" "" $branch)
                set -l worktree_path (_gtr_get_worktree_path $branch_name)

                if test -d "$worktree_path"
                    echo "Removing worktree: $branch_name"
                    git worktree remove "$worktree_path"
                    git branch -d $branch
                end
            end

            # Pull latest changes if we moved to main
            if test "$moved_to_main" = true
                echo "Pulling latest changes..."
                git pull
            end

            echo "âœ“ Cleanup complete"
        case '*'
            echo "Aborted."
    end
end

# gwt-status - Show status of all worktrees
function gwt-status --description "Show git status for all worktrees"
    echo "Status of all worktrees:"
    echo ""

    for worktree in (git worktree list --porcelain | grep "worktree " | cut -d' ' -f2-)
        if test -d "$worktree"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“ $worktree"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            pushd "$worktree"
            git status --short --branch
            popd
            echo ""
        end
    end
end

# gwt-branch-from-current - Create a worktree from the current branch
function gwt-branch-from-current --description "Create a worktree for a new branch based on current branch"
    if test (count $argv) -ne 1
        echo "Usage: gwt-branch-from-current <new-branch-name>"
        return 1
    end

    set -l new_branch $argv[1]
    set -l current_branch (git branch --show-current)
    set -l worktree_path (_gtr_get_worktree_path $new_branch)
    or return 1

    if test -d "$worktree_path"
        echo "Worktree already exists: $worktree_path"
        return 1
    end

    # Ensure the repo-specific worktree directory exists
    set -l repo_dir (_gtr_get_repo_worktree_dir)
    if not test -d "$repo_dir"
        mkdir -p "$repo_dir"
    end

    echo "Creating worktree '$new_branch' from current branch '$current_branch'..."
    git worktree add -b "claude/$new_branch" "$worktree_path" "$current_branch"

    if test $status -eq 0
        echo "âœ“ Worktree created at: $worktree_path"
        echo "  Branch: claude/$new_branch (based on $current_branch)"
    end
end

# Completion for gtr command
complete -c gtr -n "__fish_use_subcommand" -a "create" -d "Create worktrees"
complete -c gtr -n "__fish_use_subcommand" -a "finish" -d "Commit, merge, cleanup workflow"
complete -c gtr -n "__fish_use_subcommand" -a "done" -d "Cleanup after external merge"
complete -c gtr -n "__fish_use_subcommand" -a "cd" -d "Change to worktree directory"
complete -c gtr -n "__fish_use_subcommand" -a "claude" -d "Launch Claude in worktree"
complete -c gtr -n "__fish_use_subcommand" -a "list" -d "List all worktrees"
complete -c gtr -n "__fish_use_subcommand" -a "rm" -d "Remove worktrees"
complete -c gtr -n "__fish_use_subcommand" -a "prune" -d "Clean up stale references"
